# Android常用设计模式

### 单例
```java
public class Singleton{
    private volatile static Singleton instance;
    //将默认的构造函数私有化，防止其他类手动new
    private Singleton(){};
    public static Singleton getInstance(){
        if(instance==null){
            sychronized(Singleton.class){
                if(instance==null)
                    instance=new Singleton();
            }
        }
        return instatnce;
    }
}
```

### Builder
AlertDialog

### 原型模式
Intent

### 工厂方法模式
定义：定义一个创建对象的接口，让子类决定实例化哪个类

### 抽象工厂模式
定义：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要制定他们的具体类

### 观察者模式
定义：定义了对象之间的一对多的关系，其实就是1对n，当“1”发生变化时，“n”全部得到通知，并更新。

### 策略模式
定义：有一系列的算法，将每个算法封装起来（每个算法可以封装到不同的类中），各个算法之间可以替换，策略模式让算法独立于使用它的客户而独立变化。
LinearInterpolator

### 状态模式

### 责任链模式

### 解释器模式

### 命令模式

### 迭代器模式
定义：提供一种方法顺序访问一个容器对象中的各个元素，而不需要暴露该对象的内部表示。

### 中介者模式
定义：中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显调用，从而使他们可以轻松耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用保证这些作用可以彼此独立的变化，中介者模式将多对多的相互作用转为一对多的相互作用。

### 代理模式
定义：为其他类提供一种代理以控制这个对象的访问。

### 适配器模式
定义：把一个类的接口变换成客户端所期待的另一个接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

### 装饰模式
定义：动态的给一个对象添加额外的智者，就增加功能来说，装饰模式比子类继承的方式更灵活。

### 享元模式
定义：使用享元对象有效地支持大量的细粒度对象。



### 参考
* [从Android代码中来记忆23种设计模式](https://www.jianshu.com/p/1a9f571ad7c0)
