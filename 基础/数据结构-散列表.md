# 数据结构-离散表

### HashMap
*  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表
*  HashMap的实例有俩个参数影响其性能：`初始容量` 和`装填因子`
*  HashMap实现不同步，线程不安全。HashTable线程安全
*  HashMap中的key-value都是存储在Entry中的
*  HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性
*  解决哈希冲突主要有三种方法：定址法，拉链法，再散列法。**HashMap是采用拉链法解决哈希冲突的**。注：拉链法是将相同hash值的对象组成一个链表放在hash值对应的槽位；用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。

### HashSet

### HashTable

### 注意
Java中的对象覆写`equals`方法时，最好同时覆写`hashCode`，否则会引起对象存入`Hashxxx`出现`hashCode`重复导致bug的情况


### 参考
* [浅谈Java中的hashcode方法](https://www.cnblogs.com/dolphin0520/p/3681042.html)